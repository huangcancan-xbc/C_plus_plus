//牛客：值周
//https://ac.nowcoder.com/acm/contest/20960/1018
//这道题和牛客：[NOIP2005]校门外的树是一样的思路，但是这道题的数据量非常大，需要选择更高效快速的算法。


//差分数组的思想：
//差分数组用于高效处理区间增量问题，它的核心思想是：
//1.在区间的起始位置进行增量操作；
//2.在区间的结束位置的下一个位置进行减量操作。
//3.这样，通过一次遍历就可以恢复出整个数组的状态，特别适用于多个区间修改的场景。


//代码的具体思路：
//你有一个长度为 l 的区间，并且有 m 个区间操作，要求这些操作标记覆盖的区间。
//差分数组 arr[] 用来记录某个位置的变化：
//arr[left]++表示区间从 left 开始有一个增量。
//arr[right + 1]--表示区间在 right + 1 处取消这个增量（即减去前面的增量）。
//最后通过一次累加差分数组 arr[] 来恢复每个位置的实际标记值，并统计没有被标记的区域（sum == 0）。


//这串代码同样适用于解决牛客：[NOIP2005]校门外的树，但是牛客：[NOIP2005]校门外的树的代码不能直接用在这道题上，需要进行一些修改！
#include<iostream>
using namespace std;
// 定义一个很大的数组，来表示差分数组
long long arr[100000010];

int main()
{
    int l = 0, m = 0, ans = 0;   // l表示区间长度，m表示操作次数，ans用来统计未被覆盖的位置
    cin >> l >> m;

    // 差分操作，记录每个区间的开始和结束
    while (m--)
    {
        int left = 0, right = 0;
        cin >> left >> right;

        // 在left位置加1，表示区间从这里开始
        arr[left]++;

        // 在right + 1位置减1，表示区间在这里结束
        arr[right + 1]--;
    }

    // 恢复第0个位置的状态
    int sum = arr[0];  // sum 用于存储当前位置的累加结果，恢复出原数组的状态

    // 如果第0个位置没有被标记（sum == 0），统计它
    if (!sum)
    {
        ans++;
    }

    // 从第1个位置开始，遍历到第l个位置，逐步恢复数组的状态
    for (long long i = 1; i <= l; i++)
    {
        sum += arr[i];  // 利用差分数组，累加得到当前位置的实际值

        // 如果当前位置没有被覆盖（sum == 0），则统计该位置
        if (!sum)
        {
            ans++;
        }
    }

    // 输出统计结果，表示未被覆盖的位置数
    cout << ans << endl;

    return 0;
}

//示例演示，帮助理解差分数组的思想：
//假设有一个长度为 l = 10 的区间，m = 2 个操作：
//操作 1：[2, 5]
//操作 2：[7, 9]
//
//差分数组变化：
//初始 arr : 00000000000
//
//操作1->arr[2]++, arr[6]-- : 00100100000
//操作2->arr[7]++, arr[10]-- : 00100110000
//累加结果（恢复原数组）：sum : 00011100011
//结果分析：未被覆盖的区域在第 0、1、6、10 号位置，ans = 4。